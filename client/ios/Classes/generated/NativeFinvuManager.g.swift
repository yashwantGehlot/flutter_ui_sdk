// Autogenerated from Pigeon (v14.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFinvuConfig {
  var finvuEndpoint: String
  var certificatePins: [String?]? = nil

  static func fromList(_ list: [Any?]) -> NativeFinvuConfig? {
    let finvuEndpoint = list[0] as! String
    let certificatePins: [String?]? = nilOrValue(list[1])

    return NativeFinvuConfig(
      finvuEndpoint: finvuEndpoint,
      certificatePins: certificatePins
    )
  }
  func toList() -> [Any?] {
    return [
      finvuEndpoint,
      certificatePins,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeHandleInfo {
  var userId: String

  static func fromList(_ list: [Any?]) -> NativeHandleInfo? {
    let userId = list[0] as! String

    return NativeHandleInfo(
      userId: userId
    )
  }
  func toList() -> [Any?] {
    return [
      userId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPDetails {
  var fipId: String
  var typeIdentifiers: [NativeFIPFiTypeIdentifier?]

  static func fromList(_ list: [Any?]) -> NativeFIPDetails? {
    let fipId = list[0] as! String
    let typeIdentifiers = list[1] as! [NativeFIPFiTypeIdentifier?]

    return NativeFIPDetails(
      fipId: fipId,
      typeIdentifiers: typeIdentifiers
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      typeIdentifiers,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPFiTypeIdentifier {
  var fiType: String
  var identifiers: [NativeTypeIdentifier?]

  static func fromList(_ list: [Any?]) -> NativeFIPFiTypeIdentifier? {
    let fiType = list[0] as! String
    let identifiers = list[1] as! [NativeTypeIdentifier?]

    return NativeFIPFiTypeIdentifier(
      fiType: fiType,
      identifiers: identifiers
    )
  }
  func toList() -> [Any?] {
    return [
      fiType,
      identifiers,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeTypeIdentifier {
  var type: String
  var category: String

  static func fromList(_ list: [Any?]) -> NativeTypeIdentifier? {
    let type = list[0] as! String
    let category = list[1] as! String

    return NativeTypeIdentifier(
      type: type,
      category: category
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      category,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeTypeIdentifierInfo {
  var category: String
  var type: String
  var value: String

  static func fromList(_ list: [Any?]) -> NativeTypeIdentifierInfo? {
    let category = list[0] as! String
    let type = list[1] as! String
    let value = list[2] as! String

    return NativeTypeIdentifierInfo(
      category: category,
      type: type,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      category,
      type,
      value,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDiscoveredAccountInfo {
  var accountType: String
  var accountReferenceNumber: String
  var maskedAccountNumber: String
  var fiType: String

  static func fromList(_ list: [Any?]) -> NativeDiscoveredAccountInfo? {
    let accountType = list[0] as! String
    let accountReferenceNumber = list[1] as! String
    let maskedAccountNumber = list[2] as! String
    let fiType = list[3] as! String

    return NativeDiscoveredAccountInfo(
      accountType: accountType,
      accountReferenceNumber: accountReferenceNumber,
      maskedAccountNumber: maskedAccountNumber,
      fiType: fiType
    )
  }
  func toList() -> [Any?] {
    return [
      accountType,
      accountReferenceNumber,
      maskedAccountNumber,
      fiType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDiscoveredAccountsResponse {
  var accounts: [NativeDiscoveredAccountInfo?]

  static func fromList(_ list: [Any?]) -> NativeDiscoveredAccountsResponse? {
    let accounts = list[0] as! [NativeDiscoveredAccountInfo?]

    return NativeDiscoveredAccountsResponse(
      accounts: accounts
    )
  }
  func toList() -> [Any?] {
    return [
      accounts,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAccountLinkingRequestReference {
  var referenceNumber: String

  static func fromList(_ list: [Any?]) -> NativeAccountLinkingRequestReference? {
    let referenceNumber = list[0] as! String

    return NativeAccountLinkingRequestReference(
      referenceNumber: referenceNumber
    )
  }
  func toList() -> [Any?] {
    return [
      referenceNumber,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountInfo {
  var customerAddress: String
  var linkReferenceNumber: String
  var accountReferenceNumber: String
  var status: String

  static func fromList(_ list: [Any?]) -> NativeLinkedAccountInfo? {
    let customerAddress = list[0] as! String
    let linkReferenceNumber = list[1] as! String
    let accountReferenceNumber = list[2] as! String
    let status = list[3] as! String

    return NativeLinkedAccountInfo(
      customerAddress: customerAddress,
      linkReferenceNumber: linkReferenceNumber,
      accountReferenceNumber: accountReferenceNumber,
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      customerAddress,
      linkReferenceNumber,
      accountReferenceNumber,
      status,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConfirmAccountLinkingInfo {
  var linkedAccounts: [NativeLinkedAccountInfo?]

  static func fromList(_ list: [Any?]) -> NativeConfirmAccountLinkingInfo? {
    let linkedAccounts = list[0] as! [NativeLinkedAccountInfo?]

    return NativeConfirmAccountLinkingInfo(
      linkedAccounts: linkedAccounts
    )
  }
  func toList() -> [Any?] {
    return [
      linkedAccounts,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountsResponse {
  var linkedAccounts: [NativeLinkedAccountDetailsInfo?]

  static func fromList(_ list: [Any?]) -> NativeLinkedAccountsResponse? {
    let linkedAccounts = list[0] as! [NativeLinkedAccountDetailsInfo?]

    return NativeLinkedAccountsResponse(
      linkedAccounts: linkedAccounts
    )
  }
  func toList() -> [Any?] {
    return [
      linkedAccounts,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountDetailsInfo {
  var userId: String
  var fipId: String
  var fipName: String
  var maskedAccountNumber: String
  var accountReferenceNumber: String
  var linkReferenceNumber: String
  var consentIdList: [String?]? = nil
  var fiType: String
  var accountType: String
  var linkedAccountUpdateTimestamp: String? = nil
  var authenticatorType: String

  static func fromList(_ list: [Any?]) -> NativeLinkedAccountDetailsInfo? {
    let userId = list[0] as! String
    let fipId = list[1] as! String
    let fipName = list[2] as! String
    let maskedAccountNumber = list[3] as! String
    let accountReferenceNumber = list[4] as! String
    let linkReferenceNumber = list[5] as! String
    let consentIdList: [String?]? = nilOrValue(list[6])
    let fiType = list[7] as! String
    let accountType = list[8] as! String
    let linkedAccountUpdateTimestamp: String? = nilOrValue(list[9])
    let authenticatorType = list[10] as! String

    return NativeLinkedAccountDetailsInfo(
      userId: userId,
      fipId: fipId,
      fipName: fipName,
      maskedAccountNumber: maskedAccountNumber,
      accountReferenceNumber: accountReferenceNumber,
      linkReferenceNumber: linkReferenceNumber,
      consentIdList: consentIdList,
      fiType: fiType,
      accountType: accountType,
      linkedAccountUpdateTimestamp: linkedAccountUpdateTimestamp,
      authenticatorType: authenticatorType
    )
  }
  func toList() -> [Any?] {
    return [
      userId,
      fipId,
      fipName,
      maskedAccountNumber,
      accountReferenceNumber,
      linkReferenceNumber,
      consentIdList,
      fiType,
      accountType,
      linkedAccountUpdateTimestamp,
      authenticatorType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFinancialInformationEntity {
  var id: String
  var name: String

  static func fromList(_ list: [Any?]) -> NativeFinancialInformationEntity? {
    let id = list[0] as! String
    let name = list[1] as! String

    return NativeFinancialInformationEntity(
      id: id,
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      name,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentPurposeInfo {
  var code: String
  var text: String

  static func fromList(_ list: [Any?]) -> NativeConsentPurposeInfo? {
    let code = list[0] as! String
    let text = list[1] as! String

    return NativeConsentPurposeInfo(
      code: code,
      text: text
    )
  }
  func toList() -> [Any?] {
    return [
      code,
      text,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentRequestDetailInfo {
  var consentHandleId: String
  var consentId: String? = nil
  var financialInformationUser: NativeFinancialInformationEntity
  var consentPurposeInfo: NativeConsentPurposeInfo
  var consentDisplayDescriptions: [String?]
  var dataDateTimeRange: NativeDateTimeRange
  var consentDateTimeRange: NativeDateTimeRange
  var consentDataFrequency: NativeConsentDataFrequency
  var consentDataLifePeriod: NativeConsentDataLifePeriod
  var fiTypes: [String?]? = nil
  var statusLastUpdateTimestamp: String? = nil

  static func fromList(_ list: [Any?]) -> NativeConsentRequestDetailInfo? {
    let consentHandleId = list[0] as! String
    let consentId: String? = nilOrValue(list[1])
    let financialInformationUser = NativeFinancialInformationEntity.fromList(list[2] as! [Any?])!
    let consentPurposeInfo = NativeConsentPurposeInfo.fromList(list[3] as! [Any?])!
    let consentDisplayDescriptions = list[4] as! [String?]
    let dataDateTimeRange = NativeDateTimeRange.fromList(list[5] as! [Any?])!
    let consentDateTimeRange = NativeDateTimeRange.fromList(list[6] as! [Any?])!
    let consentDataFrequency = NativeConsentDataFrequency.fromList(list[7] as! [Any?])!
    let consentDataLifePeriod = NativeConsentDataLifePeriod.fromList(list[8] as! [Any?])!
    let fiTypes: [String?]? = nilOrValue(list[9])
    let statusLastUpdateTimestamp: String? = nilOrValue(list[10])

    return NativeConsentRequestDetailInfo(
      consentHandleId: consentHandleId,
      consentId: consentId,
      financialInformationUser: financialInformationUser,
      consentPurposeInfo: consentPurposeInfo,
      consentDisplayDescriptions: consentDisplayDescriptions,
      dataDateTimeRange: dataDateTimeRange,
      consentDateTimeRange: consentDateTimeRange,
      consentDataFrequency: consentDataFrequency,
      consentDataLifePeriod: consentDataLifePeriod,
      fiTypes: fiTypes,
      statusLastUpdateTimestamp: statusLastUpdateTimestamp
    )
  }
  func toList() -> [Any?] {
    return [
      consentHandleId,
      consentId,
      financialInformationUser.toList(),
      consentPurposeInfo.toList(),
      consentDisplayDescriptions,
      dataDateTimeRange.toList(),
      consentDateTimeRange.toList(),
      consentDataFrequency.toList(),
      consentDataLifePeriod.toList(),
      fiTypes,
      statusLastUpdateTimestamp,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDateTimeRange {
  var from: String
  var to: String

  static func fromList(_ list: [Any?]) -> NativeDateTimeRange? {
    let from = list[0] as! String
    let to = list[1] as! String

    return NativeDateTimeRange(
      from: from,
      to: to
    )
  }
  func toList() -> [Any?] {
    return [
      from,
      to,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentDataFrequency {
  var unit: String
  var value: Double

  static func fromList(_ list: [Any?]) -> NativeConsentDataFrequency? {
    let unit = list[0] as! String
    let value = list[1] as! Double

    return NativeConsentDataFrequency(
      unit: unit,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      unit,
      value,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentDataLifePeriod {
  var unit: String
  var value: Double

  static func fromList(_ list: [Any?]) -> NativeConsentDataLifePeriod? {
    let unit = list[0] as! String
    let value = list[1] as! Double

    return NativeConsentDataLifePeriod(
      unit: unit,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      unit,
      value,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentInfo {
  var consentId: String
  var fipId: String? = nil

  static func fromList(_ list: [Any?]) -> NativeConsentInfo? {
    let consentId = list[0] as! String
    let fipId: String? = nilOrValue(list[1])

    return NativeConsentInfo(
      consentId: consentId,
      fipId: fipId
    )
  }
  func toList() -> [Any?] {
    return [
      consentId,
      fipId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeProcessConsentRequestResponse {
  var consentIntentId: String? = nil
  var consentInfo: [NativeConsentInfo?]? = nil

  static func fromList(_ list: [Any?]) -> NativeProcessConsentRequestResponse? {
    let consentIntentId: String? = nilOrValue(list[0])
    let consentInfo: [NativeConsentInfo?]? = nilOrValue(list[1])

    return NativeProcessConsentRequestResponse(
      consentIntentId: consentIntentId,
      consentInfo: consentInfo
    )
  }
  func toList() -> [Any?] {
    return [
      consentIntentId,
      consentInfo,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserConsentInfoDetails {
  var consentId: String
  var consentIntentEntityId: String? = nil
  var consentIntentEntityName: String
  var consentIdList: [String?]
  var consentIntentUpdateTimestamp: String
  var consentPurposeText: String
  var status: String? = nil

  static func fromList(_ list: [Any?]) -> NativeUserConsentInfoDetails? {
    let consentId = list[0] as! String
    let consentIntentEntityId: String? = nilOrValue(list[1])
    let consentIntentEntityName = list[2] as! String
    let consentIdList = list[3] as! [String?]
    let consentIntentUpdateTimestamp = list[4] as! String
    let consentPurposeText = list[5] as! String
    let status: String? = nilOrValue(list[6])

    return NativeUserConsentInfoDetails(
      consentId: consentId,
      consentIntentEntityId: consentIntentEntityId,
      consentIntentEntityName: consentIntentEntityName,
      consentIdList: consentIdList,
      consentIntentUpdateTimestamp: consentIntentUpdateTimestamp,
      consentPurposeText: consentPurposeText,
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      consentId,
      consentIntentEntityId,
      consentIntentEntityName,
      consentIdList,
      consentIntentUpdateTimestamp,
      consentPurposeText,
      status,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAccountAggregator {
  var id: String

  static func fromList(_ list: [Any?]) -> NativeAccountAggregator? {
    let id = list[0] as! String

    return NativeAccountAggregator(
      id: id
    )
  }
  func toList() -> [Any?] {
    return [
      id,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPReference {
  var fipId: String
  var fipName: String

  static func fromList(_ list: [Any?]) -> NativeFIPReference? {
    let fipId = list[0] as! String
    let fipName = list[1] as! String

    return NativeFIPReference(
      fipId: fipId,
      fipName: fipName
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      fipName,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLoginOtpReference {
  var reference: String

  static func fromList(_ list: [Any?]) -> NativeLoginOtpReference? {
    let reference = list[0] as! String

    return NativeLoginOtpReference(
      reference: reference
    )
  }
  func toList() -> [Any?] {
    return [
      reference,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentHandleStatusResponse {
  var status: String

  static func fromList(_ list: [Any?]) -> NativeConsentHandleStatusResponse? {
    let status = list[0] as! String

    return NativeConsentHandleStatusResponse(
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      status,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPInfo {
  var fipId: String
  var productName: String? = nil
  var fipFitypes: [String?]
  var fipFsr: String? = nil
  var productDesc: String? = nil
  var productIconUri: String? = nil
  var enabled: Bool

  static func fromList(_ list: [Any?]) -> NativeFIPInfo? {
    let fipId = list[0] as! String
    let productName: String? = nilOrValue(list[1])
    let fipFitypes = list[2] as! [String?]
    let fipFsr: String? = nilOrValue(list[3])
    let productDesc: String? = nilOrValue(list[4])
    let productIconUri: String? = nilOrValue(list[5])
    let enabled = list[6] as! Bool

    return NativeFIPInfo(
      fipId: fipId,
      productName: productName,
      fipFitypes: fipFitypes,
      fipFsr: fipFsr,
      productDesc: productDesc,
      productIconUri: productIconUri,
      enabled: enabled
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      productName,
      fipFitypes,
      fipFsr,
      productDesc,
      productIconUri,
      enabled,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPSearchResponse {
  var searchOptions: [NativeFIPInfo?]

  static func fromList(_ list: [Any?]) -> NativeFIPSearchResponse? {
    let searchOptions = list[0] as! [NativeFIPInfo?]

    return NativeFIPSearchResponse(
      searchOptions: searchOptions
    )
  }
  func toList() -> [Any?] {
    return [
      searchOptions,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEntityInfo {
  var entityId: String
  var entityName: String
  var entityIconUri: String? = nil
  var entityLogoUri: String? = nil
  var entityLogoWithNameUri: String? = nil

  static func fromList(_ list: [Any?]) -> NativeEntityInfo? {
    let entityId = list[0] as! String
    let entityName = list[1] as! String
    let entityIconUri: String? = nilOrValue(list[2])
    let entityLogoUri: String? = nilOrValue(list[3])
    let entityLogoWithNameUri: String? = nilOrValue(list[4])

    return NativeEntityInfo(
      entityId: entityId,
      entityName: entityName,
      entityIconUri: entityIconUri,
      entityLogoUri: entityLogoUri,
      entityLogoWithNameUri: entityLogoWithNameUri
    )
  }
  func toList() -> [Any?] {
    return [
      entityId,
      entityName,
      entityIconUri,
      entityLogoUri,
      entityLogoWithNameUri,
    ]
  }
}

private class NativeFinvuManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return NativeAccountAggregator.fromList(self.readValue() as! [Any?])
      case 129:
        return NativeAccountLinkingRequestReference.fromList(self.readValue() as! [Any?])
      case 130:
        return NativeConfirmAccountLinkingInfo.fromList(self.readValue() as! [Any?])
      case 131:
        return NativeConsentDataFrequency.fromList(self.readValue() as! [Any?])
      case 132:
        return NativeConsentDataLifePeriod.fromList(self.readValue() as! [Any?])
      case 133:
        return NativeConsentHandleStatusResponse.fromList(self.readValue() as! [Any?])
      case 134:
        return NativeConsentInfo.fromList(self.readValue() as! [Any?])
      case 135:
        return NativeConsentPurposeInfo.fromList(self.readValue() as! [Any?])
      case 136:
        return NativeConsentRequestDetailInfo.fromList(self.readValue() as! [Any?])
      case 137:
        return NativeDateTimeRange.fromList(self.readValue() as! [Any?])
      case 138:
        return NativeDiscoveredAccountInfo.fromList(self.readValue() as! [Any?])
      case 139:
        return NativeDiscoveredAccountsResponse.fromList(self.readValue() as! [Any?])
      case 140:
        return NativeEntityInfo.fromList(self.readValue() as! [Any?])
      case 141:
        return NativeFIPDetails.fromList(self.readValue() as! [Any?])
      case 142:
        return NativeFIPFiTypeIdentifier.fromList(self.readValue() as! [Any?])
      case 143:
        return NativeFIPInfo.fromList(self.readValue() as! [Any?])
      case 144:
        return NativeFIPReference.fromList(self.readValue() as! [Any?])
      case 145:
        return NativeFIPSearchResponse.fromList(self.readValue() as! [Any?])
      case 146:
        return NativeFinancialInformationEntity.fromList(self.readValue() as! [Any?])
      case 147:
        return NativeFinvuConfig.fromList(self.readValue() as! [Any?])
      case 148:
        return NativeHandleInfo.fromList(self.readValue() as! [Any?])
      case 149:
        return NativeLinkedAccountDetailsInfo.fromList(self.readValue() as! [Any?])
      case 150:
        return NativeLinkedAccountInfo.fromList(self.readValue() as! [Any?])
      case 151:
        return NativeLinkedAccountsResponse.fromList(self.readValue() as! [Any?])
      case 152:
        return NativeLoginOtpReference.fromList(self.readValue() as! [Any?])
      case 153:
        return NativeProcessConsentRequestResponse.fromList(self.readValue() as! [Any?])
      case 154:
        return NativeTypeIdentifier.fromList(self.readValue() as! [Any?])
      case 155:
        return NativeTypeIdentifierInfo.fromList(self.readValue() as! [Any?])
      case 156:
        return NativeUserConsentInfoDetails.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class NativeFinvuManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? NativeAccountAggregator {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAccountLinkingRequestReference {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConfirmAccountLinkingInfo {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentDataFrequency {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentDataLifePeriod {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentHandleStatusResponse {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentInfo {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentPurposeInfo {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentRequestDetailInfo {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDateTimeRange {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDiscoveredAccountInfo {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDiscoveredAccountsResponse {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEntityInfo {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPDetails {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPFiTypeIdentifier {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPInfo {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPReference {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPSearchResponse {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFinancialInformationEntity {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFinvuConfig {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? NativeHandleInfo {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountDetailsInfo {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountInfo {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountsResponse {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLoginOtpReference {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? NativeProcessConsentRequestResponse {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? NativeTypeIdentifier {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? NativeTypeIdentifierInfo {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserConsentInfoDetails {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NativeFinvuManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return NativeFinvuManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return NativeFinvuManagerCodecWriter(data: data)
  }
}

class NativeFinvuManagerCodec: FlutterStandardMessageCodec {
  static let shared = NativeFinvuManagerCodec(readerWriter: NativeFinvuManagerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NativeFinvuManager {
  func initialize(config: NativeFinvuConfig) throws
  func connect(completion: @escaping (Result<Void, Error>) -> Void)
  func disconnect() throws
  func isConnected() throws -> Bool
  func hasSession() throws -> Bool
  func loginWithUsernameOrMobileNumberAndConsentHandle(username: String?, mobileNumber: String?, consentHandleId: String, completion: @escaping (Result<NativeLoginOtpReference, Error>) -> Void)
  func verifyLoginOtp(otp: String, otpReference: String, completion: @escaping (Result<NativeHandleInfo, Error>) -> Void)
  func discoverAccountsAsync(fipId: String, fiTypes: [String], identifiers: [NativeTypeIdentifierInfo], completion: @escaping (Result<NativeDiscoveredAccountsResponse, Error>) -> Void)
  func discoverAccounts(fipId: String, fiTypes: [String], identifiers: [NativeTypeIdentifierInfo], completion: @escaping (Result<NativeDiscoveredAccountsResponse, Error>) -> Void)
  func linkAccounts(fipDetails: NativeFIPDetails, accounts: [NativeDiscoveredAccountInfo], completion: @escaping (Result<NativeAccountLinkingRequestReference, Error>) -> Void)
  func confirmAccountLinking(requestReference: NativeAccountLinkingRequestReference, otp: String, completion: @escaping (Result<NativeConfirmAccountLinkingInfo, Error>) -> Void)
  func fetchLinkedAccounts(completion: @escaping (Result<NativeLinkedAccountsResponse, Error>) -> Void)
  func initiateMobileVerification(mobileNumber: String, completion: @escaping (Result<Void, Error>) -> Void)
  func completeMobileVerification(mobileNumber: String, otp: String, completion: @escaping (Result<Void, Error>) -> Void)
  func fipsAllFIPOptions(completion: @escaping (Result<NativeFIPSearchResponse, Error>) -> Void)
  func fetchFIPDetails(fipId: String, completion: @escaping (Result<NativeFIPDetails, Error>) -> Void)
  func getEntityInfo(entityId: String, entityType: String, completion: @escaping (Result<NativeEntityInfo, Error>) -> Void)
  func approveConsentRequest(consentRequest: NativeConsentRequestDetailInfo, linkedAccounts: [NativeLinkedAccountDetailsInfo], completion: @escaping (Result<NativeProcessConsentRequestResponse, Error>) -> Void)
  func denyConsentRequest(consentRequest: NativeConsentRequestDetailInfo, completion: @escaping (Result<NativeProcessConsentRequestResponse, Error>) -> Void)
  func revokeConsent(consent: NativeUserConsentInfoDetails, accountAggregator: NativeAccountAggregator?, fipDetails: NativeFIPReference?, completion: @escaping (Result<Void, Error>) -> Void)
  func getConsentHandleStatus(handleId: String, completion: @escaping (Result<NativeConsentHandleStatusResponse, Error>) -> Void)
  func getConsentRequestDetails(handleId: String, completion: @escaping (Result<NativeConsentRequestDetailInfo, Error>) -> Void)
  func logout(completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class NativeFinvuManagerSetup {
  /// The codec used by NativeFinvuManager.
  static var codec: FlutterStandardMessageCodec { NativeFinvuManagerCodec.shared }
  /// Sets up an instance of `NativeFinvuManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NativeFinvuManager?) {
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configArg = args[0] as! NativeFinvuConfig
        do {
          try api.initialize(config: configArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let connectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.connect", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      connectChannel.setMessageHandler { _, reply in
        api.connect() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      connectChannel.setMessageHandler(nil)
    }
    let disconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.disconnect", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disconnectChannel.setMessageHandler { _, reply in
        do {
          try api.disconnect()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disconnectChannel.setMessageHandler(nil)
    }
    let isConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.isConnected", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isConnectedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isConnected()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isConnectedChannel.setMessageHandler(nil)
    }
    let hasSessionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.hasSession", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasSessionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.hasSession()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasSessionChannel.setMessageHandler(nil)
    }
    let loginWithUsernameOrMobileNumberAndConsentHandleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.loginWithUsernameOrMobileNumberAndConsentHandle", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loginWithUsernameOrMobileNumberAndConsentHandleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let usernameArg: String? = nilOrValue(args[0])
        let mobileNumberArg: String? = nilOrValue(args[1])
        let consentHandleIdArg = args[2] as! String
        api.loginWithUsernameOrMobileNumberAndConsentHandle(username: usernameArg, mobileNumber: mobileNumberArg, consentHandleId: consentHandleIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      loginWithUsernameOrMobileNumberAndConsentHandleChannel.setMessageHandler(nil)
    }
    let verifyLoginOtpChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.verifyLoginOtp", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      verifyLoginOtpChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let otpArg = args[0] as! String
        let otpReferenceArg = args[1] as! String
        api.verifyLoginOtp(otp: otpArg, otpReference: otpReferenceArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      verifyLoginOtpChannel.setMessageHandler(nil)
    }
    let discoverAccountsAsyncChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.discoverAccountsAsync", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      discoverAccountsAsyncChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        let fiTypesArg = args[1] as! [String]
        let identifiersArg = args[2] as! [NativeTypeIdentifierInfo]
        api.discoverAccountsAsync(fipId: fipIdArg, fiTypes: fiTypesArg, identifiers: identifiersArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      discoverAccountsAsyncChannel.setMessageHandler(nil)
    }
    let discoverAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.discoverAccounts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      discoverAccountsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        let fiTypesArg = args[1] as! [String]
        let identifiersArg = args[2] as! [NativeTypeIdentifierInfo]
        api.discoverAccounts(fipId: fipIdArg, fiTypes: fiTypesArg, identifiers: identifiersArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      discoverAccountsChannel.setMessageHandler(nil)
    }
    let linkAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.linkAccounts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      linkAccountsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipDetailsArg = args[0] as! NativeFIPDetails
        let accountsArg = args[1] as! [NativeDiscoveredAccountInfo]
        api.linkAccounts(fipDetails: fipDetailsArg, accounts: accountsArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      linkAccountsChannel.setMessageHandler(nil)
    }
    let confirmAccountLinkingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.confirmAccountLinking", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      confirmAccountLinkingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestReferenceArg = args[0] as! NativeAccountLinkingRequestReference
        let otpArg = args[1] as! String
        api.confirmAccountLinking(requestReference: requestReferenceArg, otp: otpArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      confirmAccountLinkingChannel.setMessageHandler(nil)
    }
    let fetchLinkedAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fetchLinkedAccounts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fetchLinkedAccountsChannel.setMessageHandler { _, reply in
        api.fetchLinkedAccounts() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      fetchLinkedAccountsChannel.setMessageHandler(nil)
    }
    let initiateMobileVerificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.initiateMobileVerification", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initiateMobileVerificationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mobileNumberArg = args[0] as! String
        api.initiateMobileVerification(mobileNumber: mobileNumberArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      initiateMobileVerificationChannel.setMessageHandler(nil)
    }
    let completeMobileVerificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.completeMobileVerification", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      completeMobileVerificationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mobileNumberArg = args[0] as! String
        let otpArg = args[1] as! String
        api.completeMobileVerification(mobileNumber: mobileNumberArg, otp: otpArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      completeMobileVerificationChannel.setMessageHandler(nil)
    }
    let fipsAllFIPOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fipsAllFIPOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fipsAllFIPOptionsChannel.setMessageHandler { _, reply in
        api.fipsAllFIPOptions() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      fipsAllFIPOptionsChannel.setMessageHandler(nil)
    }
    let fetchFIPDetailsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fetchFIPDetails", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fetchFIPDetailsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        api.fetchFIPDetails(fipId: fipIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      fetchFIPDetailsChannel.setMessageHandler(nil)
    }
    let getEntityInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getEntityInfo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEntityInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let entityIdArg = args[0] as! String
        let entityTypeArg = args[1] as! String
        api.getEntityInfo(entityId: entityIdArg, entityType: entityTypeArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getEntityInfoChannel.setMessageHandler(nil)
    }
    let approveConsentRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.approveConsentRequest", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      approveConsentRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentRequestArg = args[0] as! NativeConsentRequestDetailInfo
        let linkedAccountsArg = args[1] as! [NativeLinkedAccountDetailsInfo]
        api.approveConsentRequest(consentRequest: consentRequestArg, linkedAccounts: linkedAccountsArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      approveConsentRequestChannel.setMessageHandler(nil)
    }
    let denyConsentRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.denyConsentRequest", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      denyConsentRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentRequestArg = args[0] as! NativeConsentRequestDetailInfo
        api.denyConsentRequest(consentRequest: consentRequestArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      denyConsentRequestChannel.setMessageHandler(nil)
    }
    let revokeConsentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.revokeConsent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      revokeConsentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentArg = args[0] as! NativeUserConsentInfoDetails
        let accountAggregatorArg: NativeAccountAggregator? = nilOrValue(args[1])
        let fipDetailsArg: NativeFIPReference? = nilOrValue(args[2])
        api.revokeConsent(consent: consentArg, accountAggregator: accountAggregatorArg, fipDetails: fipDetailsArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      revokeConsentChannel.setMessageHandler(nil)
    }
    let getConsentHandleStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getConsentHandleStatus", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getConsentHandleStatusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let handleIdArg = args[0] as! String
        api.getConsentHandleStatus(handleId: handleIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getConsentHandleStatusChannel.setMessageHandler(nil)
    }
    let getConsentRequestDetailsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getConsentRequestDetails", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getConsentRequestDetailsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let handleIdArg = args[0] as! String
        api.getConsentRequestDetails(handleId: handleIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getConsentRequestDetailsChannel.setMessageHandler(nil)
    }
    let logoutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.logout", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logoutChannel.setMessageHandler { _, reply in
        api.logout() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      logoutChannel.setMessageHandler(nil)
    }
  }
}
